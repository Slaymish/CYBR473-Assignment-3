#include "anti_vm.h"
#include <windows.h>
#include <tlhelp32.h>
#include <string>
#include <algorithm>

using namespace std;

bool is_running_in_vm() {
    // Check for VM-specific registry keys
    HKEY hKey;
    const char* vm_keys[] = {
        "HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0",
        "SOFTWARE\\VMware, Inc.\\VMware Tools",
        "SOFTWARE\\Oracle\\VirtualBox Guest Additions",
        "SYSTEM\\ControlSet001\\Services\\VBoxService"
    };
    
    for (const char* key : vm_keys) {
        if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, key, 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
            RegCloseKey(hKey);
            return true;
        }
    }
    
    // Check for VM-specific processes
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot != INVALID_HANDLE_VALUE) {
        PROCESSENTRY32 pe32;
        pe32.dwSize = sizeof(PROCESSENTRY32);
        
        if (Process32First(hSnapshot, &pe32)) {
            do {
                string processName = pe32.szExeFile;
                transform(processName.begin(), processName.end(), processName.begin(), ::tolower);
                
                if (processName.find("vmtoolsd") != string::npos ||
                    processName.find("vboxservice") != string::npos ||
                    processName.find("vboxtray") != string::npos ||
                    processName.find("vmwaretray") != string::npos) {
                    CloseHandle(hSnapshot);
                    return true;
                }
            } while (Process32Next(hSnapshot, &pe32));
        }
        CloseHandle(hSnapshot);
    }
    
    // Check timing (VMs are often slower)
    DWORD start = GetTickCount();
    Sleep(500);
    DWORD end = GetTickCount();
    if (end - start < 450) { // If sleep was too fast, likely VM
        return true;
    }
    
    return false;
}